\(:model, :appName, ...)
    let subEps = model.endpoints where .isSub && .appName = appName;
    let package = //str.lower(//seq.join('', appName));
    $`
        package ${package}

        import (
            "context"
        )

        // ServiceInterface for ${appName::}.
        // Implementations of these methods must be provided.
        type ServiceInterface struct {
            ${(subEps =>
                let pubs = model.calls <&> {. +> (from: (:.appName, :.epName))} where .isPub;
                let pubName = \pub
                    $`${cond {'relay' <: .epPatterns: 'relay', _: 'emit'}}${
                        cond {pub.appName != appName: appName}::}${pub.eventName}`;
                $`
                    On${//seq. sub(' -> ', '', .epName)} func(ctx context.Context, msg map[string]interface{}${
                        cond pubs {
                            {}: '',
                            _: $`${pubs => $`, ${pubName(.to)} func(args ...interface{})` orderby .::}`,
                        }
                    }) error
                `
            ) orderby .::\i}

        }
    `
