\(:model, :appName, ...)
    let subEps = model.endpoints where .isSub && .appName = appName;
    let package = //str.lower(//seq.join('', appName));
    $`
package ${package}

import (
    "context"
    "fmt"
    "github.com/mlsquires/socketio"
    internal "github.com/orlade/socket-sysl/pkg"
    "log"
)

// Serve starts the server.
//
// appConfig is a type defined by the application programmer to
// hold application-level configuration.
func Serve(
    ctx context.Context,
    createService func(ctx context.Context, appConfig interface{}) (*ServiceInterface, error),
) error {
    return internal.Serve(
        ctx,
        internal.Config{Host: "localhost", Port: 3001},
        func(cfg internal.Config, serviceIntf interface{}) (interface{}, error) {
            ss, err := socketio.NewServer(nil)
            if err != nil {
                return nil, err
            }

            svc, err := createService(ctx, cfg)
            if err != nil {
                return nil, err
            }

            ss.On("connection", func(so socketio.Socket) {
                log.Println("user connected")

                ${(subEps => 
                    let relay = 'relay' <: .epPatterns;
                    let pubs = model.calls <&> {. +> (from: (:.appName, :.epName))} where .isPub;
                    $`
                    ${cond {relay: $`so.Join("${.eventName}")`}}
                    _ = so.On("${.eventName}", func(msg map[string]interface{}) {
                        _ = svc.On${//seq. sub(' -> ', '', .epName)}(ctx, msg${
                            cond {
                                relay: $`, func(args ...interface{}) {
                                    ss.BroadcastTo("${.eventName}", "${.eventName}", args...)
                                }`,
                                pubs: $`${pubs => $`, func(args ...interface{}) {
                                    so.Emit("${.to.eventName}", args...)
                                }` orderby .::}`
                            }
                        })
                    })
                `) orderby .::\i}
            })

            ss.On("error", func(so socketio.Socket, err error) {
                fmt.Printf("Error: %s\n", err)
            })

            return ss, nil
        },
    )
}
`
